'use strict';

// -----------------------------------------------------------------
//  This stub Zome code file was auto-generated by hc-scaffold
// -----------------------------------------------------------------

// -----------------------------------------------------------------
//  Exposed functions with custom logic https://developer.holochain.org/API_reference
// -----------------------------------------------------------------

function postCreate(postEntry) {
  var postHash = commit("post", postEntry);
  // Link from post to user
  commit("postLink", { Links: [{ Base: postHash, Link: App.Agent.Hash, Tag: "creator" }] });
  // Link from user to post
  commit("postLink", { Links: [{ Base: App.Agent.Hash, Link: postHash, Tag: "post" }] });
  return postHash;
}

function postRead(postHash) {
  var post = get(postHash);
  return post;
}

function postUpdate(input) {
  var postOutHash = update("post", input.postEntry, input.postHash);
  return postOutHash;
}

function postDelete(postHash) {
  var result = remove(postHash, "");
  return result;
}

function internalUserPosts(user) {
  return getLinks(user, "post", { Load: true });
}

function userPosts(user) {
  return JSON.stringify(internalUserPosts(user));
}

function myPosts() {
  return JSON.stringify(internalUserPosts(App.Agent.Hash));
}

function followingPosts() {
  var peopleFollowing = getLinks(App.Agent.Hash, "follows");
  var posts = [];
  for (var i = 0; i < peopleFollowing.length; i++) {
    posts = posts.concat(internalUserPosts(peopleFollowing[i].Hash));
  }
  return JSON.stringify(posts);
}

function friendPosts() {
  // TODO
  throw "Not implemented";
}

// -----------------------------------------------------------------
//  The Genesis Function https://developer.holochain.org/genesis
// -----------------------------------------------------------------

/**
 * Called only when your source chain is generated
 * @return {boolean} success
 */
function genesis() {
  return true;
}

function validate(entryName, entry, header, pkg, sources) {
  switch (entryName) {
    case "post":
      if (entry.review < 0 || entry.review > 5) {
        return false;
      }
      return true;
    case "postLink":
      var link = entry.Links[0];
      var baseType = get(link.Base, { GetMask: HC.GetMask.EntryType });
      switch (link.Tag) {
        case "creator":
          if (baseType != "post") {
            return false;
          }
          var linkType = get(link.Link, { GetMask: HC.GetMask.EntryType });
          return linkType == "%agent";
        case "post":
          if (baseType != "%agent") {
            return false;
          }
          var linkType = get(link.Link, { GetMask: HC.GetMask.EntryType });
          return linkType == "post";
        default:
          return false;
      }
  }
}

// -----------------------------------------------------------------
//  Validation functions for every change to the local chain or DHT
// -----------------------------------------------------------------

/**
 * Called to validate any changes to the local chain or DHT
 * @param {string} entryName - the type of entry
 * @param {*} entry - the entry data to be set
 * @param {object} header - header for the entry containing properties EntryLink, Time, and Type
 * @param {*} pkg - the extra data provided by the validate[X]Pkg methods
 * @param {object} sources - an array of strings containing the keys of any authors of this entry
 * @return {boolean} is valid?
 */
function validateCommit(entryName, entry, header, pkg, sources) {
  if (!validate(entryName, entry, header, pkg, sources)) {
    return false;
  }

  switch (entryName) {
    case "post":
    case "postLink":
      return true;
    default:
      // invalid entry name
      return false;
  }
}

/**
 * Called to validate any changes to the local chain or DHT
 * @param {string} entryName - the type of entry
 * @param {*} entry - the entry data to be set
 * @param {object} header - header for the entry containing properties EntryLink, Time, and Type
 * @param {*} pkg - the extra data provided by the validate[X]Pkg methods
 * @param {object} sources - an array of strings containing the keys of any authors of this entry
 * @return {boolean} is valid?
 */
function validatePut(entryName, entry, header, pkg, sources) {
  if (!validate(entryName, entry, header, pkg, sources)) {
    return false;
  }

  switch (entryName) {
    case "post":
    case "postLink":
      return true;
    default:
      // invalid entry name
      return false;
  }
}

/**
 * Called to validate any changes to the local chain or DHT
 * @param {string} entryName - the type of entry
 * @param {*} entry - the entry data to be set
 * @param {object} header - header for the entry containing properties EntryLink, Time, and Type
 * @param {string} replaces - the hash for the entry being updated
 * @param {*} pkg - the extra data provided by the validate[X]Pkg methods
 * @param {object} sources - an array of strings containing the keys of any authors of this entry
 * @return {boolean} is valid?
 */
function validateMod(entryName, entry, header, replaces, pkg, sources) {
  if (!validate(entryName, entry, header, pkg, sources)) {
    return false;
  }


  switch (entryName) {
    case "post":
      // return true if creator is same person sending request to modify
      return get(replaces, { GetMask: HC.GetMask.Sources })[0] == sources[0];
    case "postLink":
      var replaced = get(replaces);
      switch (replaced.Tag) {
        case "creator":
          return false;
        default:
          return false;
      }
    default:
      // invalid entry name
      return false;
  }
}

/**
 * Called to validate any changes to the local chain or DHT
 * @param {string} entryName - the type of entry
 * @param {string} hash - the hash of the entry to remove
 * @param {*} pkg - the extra data provided by the validate[X]Pkg methods
 * @param {object} sources - an array of strings containing the keys of any authors of this entry
 * @return {boolean} is valid?
 */
function validateDel(entryName, hash, pkg, sources) {
  switch (entryName) {
    case "post":
    case "postLink":
      var originalAuthors = get(hash, { GetMask: HC.GetMask.Sources });
      return originalAuthors[0] == sources[0];
    default:
      // invalid entry name
      return false;
  }
}

/**
 * Called to validate any changes to the local chain or DHT
 * @param {string} entryName - the type of entry
 * @param {string} baseHash - the hash of the base entry being linked
 * @param {?} links - ?
 * @param {*} pkg - the extra data provided by the validate[X]Pkg methods
 * @param {object} sources - an array of strings containing the keys of any authors of this entry
 * @return {boolean} is valid?
 */
function validateLink(entryName, baseHash, links, pkg, sources) {
  switch (entryName) {
    case "post":
      // Not a link
      return false;
    case "postLink":
      // Already validated
      return true;
    default:
      // invalid entry name
      return false;
  }
}

/**
 * Called to get the data needed to validate
 * @param {string} entryName - the name of entry to validate
 * @return {*} the data required for validation
 */
function validatePutPkg(entryName) {
  return null;
}

/**
 * Called to get the data needed to validate
 * @param {string} entryName - the name of entry to validate
 * @return {*} the data required for validation
 */
function validateModPkg(entryName) {
  return null;
}

/**
 * Called to get the data needed to validate
 * @param {string} entryName - the name of entry to validate
 * @return {*} the data required for validation
 */
function validateDelPkg(entryName) {
  return null;
}

/**
 * Called to get the data needed to validate
 * @param {string} entryName - the name of entry to validate
 * @return {*} the data required for validation
 */
function validateLinkPkg(entryName) {
  return null;
}