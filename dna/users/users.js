'use strict';

// -----------------------------------------------------------------
//  This stub Zome code file was auto-generated by hc-scaffold
// -----------------------------------------------------------------

// -----------------------------------------------------------------
//  Exposed functions with custom logic https://developer.holochain.org/API_reference
// -----------------------------------------------------------------

function userRead(userHash) {
  var user = get(userHash);
  return user;
}

function userUpdate(input) {
  var userOutHash = update("user", input.userEntry, input.userHash);
  return userOutHash;
}

function locationCreate(locationEntry) {
  var locationHash = commit("location", locationEntry);
  return locationHash;
}

function locationRead(locationHash) {
  var location = get(locationHash, { Local: true });
  return location;
}

function locationUpdate(input) {
  var locationOutHash = update("location", input.locationEntry, input.locationHash);
  return locationOutHash;
}

function locationDelete(locationHash) {
  var result = remove(locationHash, "");
  return result;
}

function follow(user) {
  commit("userLink", { Links: [{ Base: App.Agent.Hash, Link: user, Tag: "follows" }] });
  commit("userLink", { Links: [{ Base: user, Link: App.Agent.Hash, Tag: "followedBy" }] });
}

// -----------------------------------------------------------------
//  The Genesis Function https://developer.holochain.org/genesis
// -----------------------------------------------------------------

/**
 * Called only when your source chain is generated
 * @return {boolean} success
 */
function genesis() {
  // TODO
  debug("agent hash: " + App.Agent.Hash);
  commit("user", { "avatar": "base64 image data", "bio": "bio", "dob": "date", "facebookId": "facebook unique id", "gender": "(fe)male or something idk", "languages": ["en"], "name": "name" });
  return true;
}

// -----------------------------------------------------------------
//  Validation functions for every change to the local chain or DHT
// -----------------------------------------------------------------

function validate(entryName, entry, header, pkg, sources) {
  switch (entryName) {
    case "user":
    case "location":
      return true;
    case "userPreferenceLink":
      var link = entry.Links[0];
      var baseType = get(link.Base, { GetMask: HC.GetMask.EntryName });
      if (baseType != "%agent") {
        return false;
      }
      switch (link.Tag) {
        // TODO: user preferences
        default:
          return false;
      }
    case "userLink":
      var link = entry.Links[0];
      var baseType = get(link.Base, { GetMask: HC.GetMask.EntryType });
      if (baseType != "%agent") {
        return false;
      }
      switch (link.Tag) {
        case "follows":
        case "followedBy":
          var l = get(link.Link, { GetMask: HC.GetMask.EntryType + HC.GetMask.Sources });
          return l.EntryType == "%agent" && l.Sources[0] == sources[0];
        default:
          return false;
      }
  }
}

/**
 * Called to validate any changes to the local chain or DHT
 * @param {string} entryName - the type of entry
 * @param {*} entry - the entry data to be set
 * @param {object} header - header for the entry containing properties EntryLink, Time, and Type
 * @param {*} pkg - the extra data provided by the validate[X]Pkg methods
 * @param {object} sources - an array of strings containing the keys of any authors of this entry
 * @return {boolean} is valid?
 */
function validateCommit(entryName, entry, header, pkg, sources) {
  if (!validate(entryName, entry, header, pkg, sources)) {
    return false;
  }
  switch (entryName) {
    case "user":
    case "location":
    case "userPreferenceLink":
    case "userLink":
      return true;
    default:
      // invalid entry name
      return false;
  }
}

/**
 * Called to validate any changes to the local chain or DHT
 * @param {string} entryName - the type of entry
 * @param {*} entry - the entry data to be set
 * @param {object} header - header for the entry containing properties EntryLink, Time, and Type
 * @param {*} pkg - the extra data provided by the validate[X]Pkg methods
 * @param {object} sources - an array of strings containing the keys of any authors of this entry
 * @return {boolean} is valid?
 */
function validatePut(entryName, entry, header, pkg, sources) {
  if (!validate(entryName, entry, header, pkg, sources)) {
    return false;
  }
  switch (entryName) {
    case "user":
    case "location":
    case "userPreferenceLink":
    case "userLink":
      return true;
    default:
      // invalid entry name
      return false;
  }
}

/**
 * Called to validate any changes to the local chain or DHT
 * @param {string} entryName - the type of entry
 * @param {*} entry - the entry data to be set
 * @param {object} header - header for the entry containing properties EntryLink, Time, and Type
 * @param {string} replaces - the hash for the entry being updated
 * @param {*} pkg - the extra data provided by the validate[X]Pkg methods
 * @param {object} sources - an array of strings containing the keys of any authors of this entry
 * @return {boolean} is valid?
 */
function validateMod(entryName, entry, header, replaces, pkg, sources) {
  if (!validate(entryName, entry, header, pkg, sources)) {
    return false;
  }
  switch (entryName) {
    case "user":
    case "userLink":
    case "userPreferenceLink":
      var originalAuthors = get(replaces, { GetMask: HC.GetMask.Sources });
      return originalAuthors[0] == sources[0];
    case "location":
      // Private entries do not have sources
      return true;
    default:
      // invalid entry name
      return false;
  }
}

/**
 * Called to validate any changes to the local chain or DHT
 * @param {string} entryName - the type of entry
 * @param {string} hash - the hash of the entry to remove
 * @param {*} pkg - the extra data provided by the validate[X]Pkg methods
 * @param {object} sources - an array of strings containing the keys of any authors of this entry
 * @return {boolean} is valid?
 */
function validateDel(entryName, hash, pkg, sources) {
  if (!validate(entryName, entry, header, pkg, sources)) {
    return false;
  }

  switch (entryName) {
    case "user":
      return false;
    case "location":
      // Private entries do not have sources
      return true;
    case "userPreferenceLink":
    case "userLink":
      var originalAuthors = get(hash, { GetMask: HC.GetMask.Sources });
      return originalAuthors[0] == sources[0];
    default:
      // invalid entry name
      return false;
  }
}

/**
 * Called to validate any changes to the local chain or DHT
 * @param {string} entryName - the type of entry
 * @param {string} baseHash - the hash of the base entry being linked
 * @param {?} links - ?
 * @param {*} pkg - the extra data provided by the validate[X]Pkg methods
 * @param {object} sources - an array of strings containing the keys of any authors of this entry
 * @return {boolean} is valid?
 */
function validateLink(entryName, baseHash, links, pkg, sources) {
  switch (entryName) {
    case "user":
    case "location":
      // Not a link
      return false;
    case "userPreferenceLink":
    case "userLink":
      // Already validated by validatePut
      return true;
    default:
      // invalid entry name
      return false;
  }
}

/**
 * Called to get the data needed to validate
 * @param {string} entryName - the name of entry to validate
 * @return {*} the data required for validation
 */
function validatePutPkg(entryName) {
  return null;
}

/**
 * Called to get the data needed to validate
 * @param {string} entryName - the name of entry to validate
 * @return {*} the data required for validation
 */
function validateModPkg(entryName) {
  return null;
}

/**
 * Called to get the data needed to validate
 * @param {string} entryName - the name of entry to validate
 * @return {*} the data required for validation
 */
function validateDelPkg(entryName) {
  return null;
}

/**
 * Called to get the data needed to validate
 * @param {string} entryName - the name of entry to validate
 * @return {*} the data required for validation
 */
function validateLinkPkg(entryName) {
  return null;
}